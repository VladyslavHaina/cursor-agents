---
description: "Change management: minimal diffs, tests, verification, rollback"
alwaysApply: true
---

## Change Management (Always)

- No drive-by refactors:
  - Don’t rename, reformat, or reorganize unrelated code.
  - If you notice a separate issue, call it out as a follow-up.

- Keep diffs reviewable:
  - Prefer incremental edits over sweeping changes.
  - Preserve existing patterns unless they are the source of the problem.

- Repo hygiene (folders stay clean):
  - Put new files in the most obvious existing folder; avoid creating new top-level folders unless truly necessary.
  - Keep structure shallow and predictable; avoid deep nesting and “misc/tmp” dumping grounds.
  - If you must move/rename: do it in small batches, update all references, and include verification + rollback steps.
  - Don’t leave behind stray scratch files or duplicated configs; remove/relocate anything you introduce that isn’t part of the final solution.

- Tests + behavior:
  - If behavior changes, add or adjust tests accordingly.
  - Avoid flaky tests; prefer deterministic unit/integration tests.

- Verification is mandatory:
  - Provide concrete steps to validate the change.
  - Include expected outcomes.

- Risk-based rollout:
  - If risk is more than low (infra/auth/data), include:
    - rollback steps
    - blast radius notes
    - safe rollout strategy (canary/feature flag/plan-first)

- Admin / destructive operations:
  - Use `diff`/`plan`/`--dry-run` equivalents before applying changes.
  - Require explicit user confirmation for deletes, irreversible changes, or production writes.
  - Execute in small batches and verify after each batch.

- PR/commit conventions (when applicable):
  - Use conventional, descriptive titles (e.g., `fix:`, `feat:`, `chore:`).
  - Include a brief “what/why” summary and “how to verify.”
